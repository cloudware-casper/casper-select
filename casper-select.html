<!--
  - Copyright (c) 2014-2016 Cloudware S.A. All rights reserved.
  -
  - This file is part of casper-select.
  -
  - casper-select is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-select  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-select.  If not, see <http://www.gnu.org/licenses/>.
  -
-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../casper-icons/casper-icons.html">
<link rel="import" href="../paper-input/paper-input-container.html">
<link rel="import" href="../iron-overlay-behavior/iron-overlay-behavior.html">
<link rel="import" href="casper-select-dropdown.html">

<dom-module id="casper-select">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      #suffixIcon {
        cursor: pointer;
      }

      /* Styles applied to the single-selection variant */
      .casper-single-selection .input-icons {
        --paper-input-suffix: {
          display: flex;
          color: #525252;
        };
      }

      .casper-single-selection .input-icons iron-icon {
        width: 15px;
        height: 15px;
        transition: color 200ms linear;
      }

      .casper-single-selection .input-icons iron-icon:hover {
        color: black;
        cursor: pointer;
      }

      /* Styles applied to the multi-selection variant */
      .casper-multi-selection .list-items {
        display: flex;
        flex-wrap: wrap;
      }

      .casper-multi-selection .list-items .list-item {
        color: #333;
        height: 18px;
        display: flex;
        outline: none;
        padding: 0 5px;
        font-size: 12px;
        cursor: default;
        user-select: none;
        line-height: 18px;
        border-radius: 3px;
        align-items: center;
        margin: 0 4px 4px 0;
        justify-content: center;
        border: 1px solid #6F6262;
      }

      .casper-multi-selection .list-items .list-item button {
        padding: 0;
        width: 10px;
        height: 10px;
        color: white;
        border: none;
        display: flex;
        outline: none;
        font-size: 12px;
        cursor: pointer;
        background: none;
        margin-right: 5px;
        user-select: none;
        border-radius: 50%;
        align-items: center;
        flex-direction: column;
        justify-content: center;
        background-color: #9E9E9E;
      }

      .casper-multi-selection .list-items .list-item button:hover {
        background-color: #686868;
      }

      .casper-multi-selection[disabled] .list-items .list-item button {
        display: none;
      }

      .casper-multi-selection .list-items .list-item button iron-icon {
        width: 100%;
        height: 100%;
      }

      .casper-multi-selection .list-item-input {
        width: 0;
        flex-grow: 1;
        overflow: hidden;
      }

      .casper-multi-selection .list-item-input #searchSelf {
        border: 0;
        outline: none;
        background-color: transparent;
      }

      /* Styles applied to the dropdown */
      #dropdown {
        padding: 4px;
        display: flex;
        overflow: hidden;
        flex-direction: column;
        border: 1px solid #AAA;
        background-color: white;
        border-radius: 0 0 3px 3px;
        max-height: 99vh !important;
        box-shadow: rgba(25, 59, 103, 0.05) 0px 0px 0px 1px,
                    rgba(28, 55, 90, 0.16) 0px 2px 6px -1px,
                    rgba(28, 50, 79, 0.38) 0px 8px 24px -4px;
      }

      #dropdown-no-items {
        text-align: center;
        @apply --casper-select-dropdown-no-items;
      }

       #dropdownScroller {
        overflow: auto;
        -ms-overflow-style: -ms-autohiding-scrollbar;
        max-height: var(--casper-combo-box-overlay-max-height, 80vh);

        /* Fixes item background from getting on top of scrollbars on Safari */
        transform: translate3d(0,0,0);

        /* Enable momentum scrolling on iOS (iron-list v1.2+ no longer does it for us) */
        -webkit-overflow-scrolling: touch;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        flex-grow: 1;
      }

      #dropdownItems {
        @apply --casper-select-dropdown-items;
      }

      #dropdownItems[hidden] {
        display: none;
      }

      #dropdownItems .dropdown-item {
        display: flex;
        padding: 5px;

        min-height: 30px;
        align-items: center;
        box-sizing: border-box;
        background-color: white;
        border-bottom: 1px solid white;
        justify-content: space-between;
        @apply --casper-select-dropdown-item;
      }

      #dropdownItems .dropdown-item[hidden] {
        display: none;
      }

      #dropdownItems .dropdown-item.dropdown-item-selected {
        color: white;
        background-color: #007E8E;
        @apply --casper-select-dropdown-item-selected;
      }

      #dropdownItems .dropdown-item.dropdown-item-selected:hover {
        color: white;
        background-color: #007E8E;
        @apply --casper-select-dropdown-item-selected-hover;
      }

      #dropdownItems .dropdown-item:not(.dropdown-item-disabled):hover {
        color: white;
        background-color: var(--primary-color);
        @apply --casper-select-dropdown-item-hover;
      }

      #dropdownItems .dropdown-item .dropdown-item-highlight {
        border: 1px solid #CCC;
        font-weight: bold;
        border-radius: 4px;
        @apply --casper-select-dropdown-item-highlight;
      }

      #dropdownItems .dropdown-item .dropdown-item-text {
        flex-grow: 1;
        word-break: break-all;
      }

      #dropdownItems .dropdown-item .dropdown-item-icon {
        flex: 0 0 14px;
        @apply --casper-select-dropdown-item-icon;
      }

      #dropdownItems .dropdown-item .dropdown-item-icon iron-icon {
        width: 100%;
        height: 100%;
        display: none;
      }

      #dropdownItems .dropdown-item.dropdown-item-selected .dropdown-item-icon iron-icon {
        display: block;
      }

      #dropdownItems .dropdown-item.dropdown-item-disabled {
        color: #00000033;
        cursor: not-allowed;
        background-color: #DEDEDE;
        @apply --casper-select-dropdown-item-disabled;
      }
    </style>

    <template is="dom-if" if="[[ searchDynamic ]]">

      <!--Multi-selection variant-->
      <template is="dom-if" if="[[multiSelection]]">
        <paper-input-container
          disabled$="[[disabled]]"
          class="casper-multi-selection"
          always-float-label$="[[_shouldLabelFloat]]">
          <label slot="label">[[label]]</label>
          <iron-input slot="input">
            <div class="list-items" id="dynamicListWithInput">
              <div class="list-item-input">
                <input
                  id="searchSelf"
                  disabled$="[[disabled]]"
                  on-tap="selfInputClicked" />
              </div>
            </div>
          </iron-input>
        </paper-input-container>
      </template>

      <!--Single-selection variant-->
      <template is="dom-if" if="[[!multiSelection]]">
        <div class="casper-single-selection">
          <paper-input
            id="searchSelf"
            label="[[label]]"
            disabled="[[disabled]]"
            on-tap="selfInputClicked"
            no-label-float="[[noLabelFloat]]">
            <div class="input-icons" slot="suffix">
              <!--Only display the first icon if there are selected items-->
              <template is="dom-if" if="[[_shouldDisplayClearIcon(_selectedItems)]]">
                <iron-icon icon="casper-icons:clear" on-click="_clearSelectIconClicked"></iron-icon>
              </template>
              <iron-icon icon="casper-icons:arrow-drop-down"></iron-icon>
            </div>
          </paper-input>
        </div>
      </template>
    </template>

    <casper-select-dropdown
      id="dropdown"
      no-overlap
      dynamic-align
      no-cancel-on-esc-key
      vertical-align="auto"
      horizontal-align="auto">
      <slot name="search"></slot>
      <template is="dom-if" if="[[ searchCombo ]]">
        <paper-input tabindex="1" id="searchInput" class="paper-input" no-label-float label="pesquisar..">
          <iron-icon class="iron-icon" icon="casper-icons:search"></iron-icon>
          <iron-icon id="suffixIcon" class="iron-icon" icon="casper-icons:clear" alt="limpar" title="limpar"></iron-icon>
        </paper-input>
      </template>
      <div id="dropdownScroller">
        <iron-list
          id="dropdownItems"
          items="[[filteredItems]]"
          hidden$="[[noVisibleItems]]"
          scroll-target="dropdownScroller"
          selected-items="{{ironListSelectedItems}}"
          class$="[[_computedDisabledSelect(disabled)]]">
          <template>
            <div
              on-tap="_itemClicked"
              inner-h-t-m-l="[[_computedItemHtml(item._csHTML)]]"
              class$="dropdown-item [[ _computedItemSelectedClass(selected, index) ]] [[ _computedItemDisabledClass(item.csDisabled) ]]">
            </div>
          </template>
        </iron-list>
        <template is="dom-if" if="[[noVisibleItems]]">
          <div id="dropdown-no-items">[[emptyList]]</div>
        </template>
      </div>
      <slot name="status"></slot>
    </casper-select-dropdown>
  </template>
  <script>
    "use strict";

    class CasperSelect extends Polymer.Element {

      static get is () {
        return 'casper-select';
      }

      static get properties () {
        return {
          /**
           * Items supplied
           * @type {Object}
           */
          items: {
            type: Object,
            observer: '_itemsChanged'
          },
          /**
           * Disabled Items Stored
           * @type {Object}
           */
          disabledItems: {
            type: Object,
            observer: '_disabledItemsChanged',
            value: () => []
          },
          /**
           * Disabled Items Keys Stored
           * @type {Array}
           */
          disabledItemsKeys: {
            type: Array,
            value: () => []
          },
          /**
           * Item Column -> default: "name"
           * @type {String}
           */
          itemColumn: {
            type: String,
            value: 'name'
          },
          /**
           * Short Item Column used for multi-selection -> default: "shortName"
           * If not present will fallback to itemColumn.
           * @type {String}
           */
          shortItemColumn: {
            type: String,
            value: 'shortName'
          },
          /**
           * Key Column -> default: "id"
           * @type {String}
           */
          keyColumn: {
            type: String,
            value: 'id'
          },
          /**
           * Multi Selection Key Values Seperator
           * @type {Object}
           */
          multiSelectionValueSeperator: {
            type: String,
            value: ','
          },
          /**
           * Initial ID to be compared to "keyColumn" for initial selection
           * @type {Object}
           */
          initialId: {
            type: Object
          },
          /**
           * Dynamic Search Input - Internal Paper Input Property
           * @type {Boolean}
           */
          noLabelFloat: {
            type: Boolean,
            value: false
          },
          /**
           * Dynamic Search Innput - Internal Paper Input Property
           * @type {String}
           */
          label: {
            type: String,
            value: 'Escolha uma opção'
          },
          /**
           * Empty List String
           * @type {String}
           */
          emptyList: {
            type: String,
            value: 'Lista vazia'
          },
          /**
           * Items actually present in the select
           * @type {Object}
           */
          filteredItems: {
            type: Object,
            value: () => []
          },
          /**
           * This option doesn't allow you to enter search terms that have no matches
           * Either shows matched or prevents your input
           * @type {Boolean}
           */
          smartFilter: {
            type: Boolean,
            value: true
          },
          /**
           * Activate or disable filtering
           * @type {Boolean}
           */
          filtering: {
            type: Boolean,
            value: true
          },
          /**
           * No visible items COMPUTED flag
           * smartFilter needs to be disabled for this value to become true
           * @type {Boolean}
           */
          noVisibleItems: {
            type: Boolean,
            value: false,
            computed: '_emptyList(filteredItems)'
          },
          /**
           * Iron List Internal Selected Items - DO NOT MANIPULATE
           * @type {Object}
           */
          ironListSelectedItems: {
            type: Object
          },
          /**
           * Casper-Select Internal Selected Items
           * DO NOT MANIPULATE
           * @type {Object}
           */
          _selectedItems: {
            type: Object,
            observer: '_selectedItemsChanged'
          },
          /**
           * Casper-Select Internal Last Selected Items
           * DO NOT MANIPULATE
           * @type {Object}
           */
          lastSelectedItems: {
            type: Object,
            value: () => []
          },
          /**
           * Casper-Select current option stringified
           * @type {String}
           */
          value: {
            type: String,
            notify: true
          },
          /**
           * HTML Template for the items, with curly brackets for object value replacement
           * @type {String}
           */
          template: {
            type: String
          },
          /**
           * CSS Styling for the HTML Template that overrides
           * @type {Object}
           */
          templateStyle: {
            type: String,
            observer: '_templateStyleChanged'
          },
          /**
           * Template width per item in px
           * List Width = This value * Longest Item String
           * @type {Number}
           */
          listItemWidth: {
            type: Number,
            value: 20
          },
          /**
           * Disable the entire select
           * @type {Object}
           */
          disabled: {
            type: Boolean,
            value: false,
            observer: '_selectDisabled'
          },
          /**
           * If multi-selection should be enabled
           * @type {Boolean}
           */
          multiSelection: {
            type: Boolean,
            value: false,
            observer: '_multiSelectionChanged'
          },
          /**
           * Use multi-selection tags on the input
           * Requires: "searchDynamic" to be true
           * @type {Boolean}
           */
          multiSelectionTags: {
            type: Boolean,
            value: false
          },
          /**
           * Computed property to hold the multi-selection tags class to add to the DOM
           * @type {String}
           */
          multiSelectionTagsClass: {
            type: String,
            computed: '_multiSelectionTagsDefined(multiSelectionTags)'
          },
          /**
           * DOM Element provided to override the placeholder for the multi-selection tags
           * @type {Object}
           */
          multiSelectionTagsElementParent: {
            type: Object
          },
          /**
           * Enable or disable selections
           * @type {Boolean}
           */
          selectionEnabled: {
            type: Boolean,
            value: true,
            observer: '_selectionEnabledChanged'
          },
          /**
           * When attached to an existing element, will use that same element for filtering
           * @type {Boolean}
           */
          searchInline: {
            type: Boolean,
            value: false,
            observer: '_searchInlineChanged'
          },
          /**
           * When attached to an existing element, will add an extra input to the "select dropdown" for filtering
           * @type {Object}
           */
          searchCombo: {
            type: Boolean,
            value: false,
            observer: '_searchComboChanged'
          },
          /**
           * Dynamically shows its own input, and uses it for filtering and for showing the selected option
           * Is also computed by the other two types of searches
           * @type {Object}
           */
          searchDynamic: {
            type: Boolean,
            value: false,
            computed: '_isDynamicSearch(searchInline, searchCombo)',
            observer: '_searchDynamicChanged'
          },
          /**
           * If we are not in "multiSelection" mode, will automatically close dropdown on select
           * @type {Boolean}
           */
          closeOnSelect: {
            type: Boolean,
            value: true
          },
          /**
           * HTML Tag that embodies the Highlighted text
           * Default: span
           * @type {String}
           */
          highlightTemplateTag: {
            type: String,
            value: 'span'
          },
          /**
           * CSS class applied to the Highlight Template Tag
           * @type {String}
           */
          highlightTtemplateClass: {
            type: String,
            value: 'dropdown-item-highlight'
          },
          /**
           * Target element (if using exisitng input elements on the page) to attach the select dropdown to
           * @type {Object}
           */
          targetElement: {
            type: Object,
            observer: '_targetElementChanged'
          },
          /**
           * Fixed List Height
           * @type {String}
           */
          listHeight: String,
          /**
           * Fied List Width
           * @type {String}
           */
          listWidth: String,
          /**
           * Enforce select width to match container width
           * @type {Object}
           */
          fixedContainerWidth: {
            type: Boolean,
            value: false
          },
          /**
           * Adjust list height when filtering results
           * @type {Boolean}
           */
          resizeOnFilter: {
            type: Boolean,
            value: true
          },
          /**
           * Current status of the dropdown
           * @type {Boolean}
           */
          opened: {
            type: Boolean,
            value: false
          },
          /**
           * Resets filtering and search term on a new attachment
           * @type {Boolean}
           */
          resetOnOpen: {
            type: Boolean,
            value: false
          },
          /**
           * Hides the clear icon button.
           * @type {Boolean}
           */
          noClearIcon: {
            type: Boolean,
            value: false
          },
        };
      }

      ready () {
        super.ready();

        this._boundSearchInputBlurred = this._searchInputBlurred.bind(this);
        this._boundSearchInputFocused = this._searchInputFocused.bind(this);
        this._boundDebounceFilterItems = this._debounceFilterItems.bind(this);
        this._boundSearchInputKeyDownHandler = this._searchInputKeyDownHandler.bind(this);
        this._boundSearchInputKeyPressHandler = this._searchInputKeyPressHandler.bind(this);
        this._boundClearSearch = this._clearSearch.bind(this);

        this.$.dropdown.addEventListener('opened-changed', e => this._onOpenedChanged(e));
        this.$.dropdown.addEventListener('iron-overlay-canceled', e => this._cancelOverlay(e));

        window.select = this;
      }

      _cancelOverlay (e) {
        if  ( e.detail.path.includes(this.searchInput) ) {
          e.preventDefault();
        }
      }

      _onOpenedChanged (e) {
        // Closing
        if ( e.detail.value === false ) {
          this.opened = false;
          if ( !this.multiSelection && ( this.searchDynamic || this.searchInline ) ) {
            this.lastSelectedItems = this._selectedItems;
            if ( this._selectedItems !== undefined ) {
              this._setValueInInput();
            } else {
              this._clearValueInput();
            }
          }
        // Opening
        } else {
          if ( typeof this._selectedIndex !== "undefined" ) {
            setTimeout(() => {
              this.$.dropdownItems.scrollToIndex( this._selectedIndex );
            }, 16);
          }
          this.opened = true;
          if ( !this.multiSelection && ( this.searchDynamic || this.searchInline ) ) {
            this._unsetValueInInput();
          }
        }
      }

      _clearValueInput () {
        this.searchInput.value = '';
      }

      _setValueInInput () {
        this._tempFiltering = this._tempFiltering || this.filtering;
        this.filtering = false;
        this.searchInput.value = this._selectedItems ? this._selectedItems[this.itemColumn] : '';
        this.searchInput.setAttribute('readonly', '');
      }

      _unsetValueInInput() {
        this.searchInput.value = "";
        this.searchInput.removeAttribute('readonly');
        this._resizeItemListHeight();
        if ( typeof this._tempFiltering !== "undefined" ) {
          this.filtering = this._tempFiltering;
          this._tempFiltering = undefined;
        }
      }

      _isDynamicSearch ( searchInline, searchCombo ) {
        return ( searchInline === false && searchCombo === false );
      }

      _searchDynamicChanged ( newSearchDynamicValue, oldSearchDynamicValue ) {
        if ( newSearchDynamicValue && !oldSearchDynamicValue ) {
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector('#searchSelf'), () => {
            if ( this.items && this.items.length > 0 ) {
              this._resizeItemListHeight();
            }
            this._setMultiSelectionTarget();
            this._unbindSearchInputListeners();
            this.searchInput = this.shadowRoot.querySelector('#searchSelf');
            this._bindSearchInputListeners();
          });
        }
      }

      _selectedItemsChanged ( newSelectedItems ) {
        this._shouldLabelFloat = this._inputHasValue();

        let listItems = this.multiSelectionTagsElementParent
          ? this.multiSelectionTagsElementParent
          : this.shadowRoot.querySelector('#dynamicListWithInput');

        if ( this.multiSelection && this.multiSelectionTags ) {
          if ( listItems ) {
            this._removeDynamicListSelectedValues(listItems);
            if ( newSelectedItems !== undefined && newSelectedItems.length > 0 ) {
              newSelectedItems.forEach( el => {
                const item = document.createElement('div');
                const itemButton = document.createElement('button');
                const itemSpan = document.createElement('span');

                const itemButtonIcon = document.createElement('iron-icon');
                itemButtonIcon.setAttribute('icon', 'casper-icons:clear');

                itemButton.appendChild(itemButtonIcon);
                itemButton.dataset.key = el[this.keyColumn];
                itemButton.addEventListener('click', this._removeOptionFromList.bind(this));
                itemSpan.innerHTML = el[this.shortItemColumn] === undefined ? el[this.itemColumn] : el[this.shortItemColumn];

                item.classList.add('list-item');
                item.appendChild(itemButton);
                item.appendChild(itemSpan);
                listItems.insertBefore(item, listItems.lastElementChild);
              });
            }
          }
          this.$.dropdown.refit();
        } else {
          this.$.dropdown.refit();
        }

        this._setValue();
        if ( !this.disabled ) {
          this.dispatchEvent(new CustomEvent('casper-select-changed', { detail: { selectedItems: newSelectedItems } }));
        }
      }

      _removeDynamicListSelectedValues( list ) {
        let elements = this.multiSelectionTagsElementParent
          ? list.querySelectorAll('div')
          : list.querySelectorAll('div:not(:last-child)');

        if ( elements.length > 0 ) {
          elements.forEach(element => list.removeChild(element));
        }
      }

      _removeOptionFromList (event) {
        const clickedKey = event.target.parentNode.dataset.key;

        for ( let [key, item] of Object.entries(this._selectedItems) ) {
          if ( item[this.keyColumn] == clickedKey ) {
            this._selectedItems.splice(key, 1);
            this._selectedItems = JSON.parse(JSON.stringify( this._selectedItems ));
            break;
          }
        }
        for ( let [key, item] of Object.entries(this.ironListSelectedItems) ) {
          if ( item[this.keyColumn] == clickedKey ) {
            this.$.dropdownItems.deselectItem( item );
            break;
          }
        }
        this.$.dropdown.refit();
        event.preventDefault();
        event.stopPropagation();
      }

      selfInputClicked () {
        if ( this.items && this.items.length > 0 && !this.disabled ) {
          if ( !this.opened ) {
            this.openDropdown();
          }
        } else {
          this.searchInput.blur();
        }
      }

      _itemClicked (event) {

        let classList = event.path.find(element => element.classList.contains('dropdown-item')).classList;

        if ( !this.selectionEnabled || classList.contains('dropdown-item-disabled') ) {
          event.preventDefault();
          event.stopPropagation();
          return;
        }

        if ( !this._selectedItems || this._selectedItems.length === 0 ) {
          this._selectedItems = [];
        }

        if ( this.multiSelection ) {
          if ( classList.contains('dropdown-item-selected') ) {
            for ( let [key, item] of Object.entries(this._selectedItems) ) {
              if ( item[this.keyColumn] == event.model.item[this.keyColumn] ) {
                this._selectedItems.splice(key, 1);
                this._selectedItems = JSON.parse(JSON.stringify( this._selectedItems ));
                return;
              }
            }
          } else {
            if ( typeof this._selectedItems === "undefined" ) {
              this._selectedItems = [];
            }
            this._selectedItems.push(event.model.item);
            this._selectedItems = JSON.parse(JSON.stringify( this._selectedItems ));
          }
        } else {
          if ( classList.contains('dropdown-item-selected') ) {
            this._selectedItems = [];
            this._selectedIndex = -1;
          } else {
            this._selectedIndex = event.model.index;
            this._selectedItems = event.model.item;
            if ( this.closeOnSelect ) {
              this.closeDropdown();
            }
          }
        }
      }

      _emptyList (items) {
        return !items || items.length === 0 ? true : false;
      }

      _clearSearch () {
        if ( this.searchInput ) {
          this.searchInput.value = "";
        }
        const sfxIcon = this.shadowRoot.querySelector("#suffixIcon");
        if ( sfxIcon ) {
          sfxIcon.style.opacity = 0;
          sfxIcon.removeEventListener('click', this._boundClearSearch);
        }
      }

      _searchInputKeyPressHandler (event) {

        if ( !this.smartFilter || !this.filtering || !this.searchInput ) {
          return;
        }

        let key = event.keyCode
        // tab, enter, esc -- just in case
        if ([9, 13, 27].includes(key)) return;

        let nextLetter = String.fromCharCode(key);
        if (nextLetter.length > 0) {
          let searchTerm = this.searchInput.value + nextLetter.trim();
          if (searchTerm.length > 0) {
            let _lastQuery = this.searchInput.value;
            this.filterItems(searchTerm);
            if (this.filteredItems.length === 0) {
              event.preventDefault();
              this.filterItems(_lastQuery);
            }
          }
        }
      }

      _searchInputKeyDownHandler (event) {
        let key = event.keyCode;
        switch (key) {
          case 8: // backspace
            if ( this.multiSelection
              && this._selectedItems
              && this._selectedItems.length > 0
              && this.searchInput.value.length === 0) {
              const lastKeySelectedItemInList = this._selectedItems[this._selectedItems.length - 1][this.keyColumn];
              this.lastSelectedItems = this.lastSelectedItems.filter(item => item[this.keyColumn] !== lastKeySelectedItemInList);

              this._selectedItems.splice(-1);
              this._selectedItems = JSON.parse(JSON.stringify( this._selectedItems ));
              for ( let [key, item] of Object.entries(this.ironListSelectedItems) ) {
                if ( item[this.keyColumn] == lastKeySelectedItemInList ) {
                  this.$.dropdownItems.deselectItem( item );
                  break;
                }
              }
              this.$.dropdown.refit();
            }
            break;
          case  9: // tab
          case 13: // enter
            this._closingKey = key == 13 ? 'enter' : (event.shiftKey === true ? 'shift+tab' : 'tab');
            if ( !this.multiSelection ) {
              this.lastSelectedItems = this._selectedItems;
              if ( this.opened ) {

                if ( this.$.dropdownItems.items.length === 1 ) {
                  this._selectedItems = this.lastSelectedItems = this.$.dropdownItems.items[0];
                }

                if ( this.closeOnSelect ) {
                  this.closeDropdown();
                }
              } else {
                if ( this.searchInput ) {
                  this.searchInput.blur();
                }
              }
            } else {
              if ( this.opened ) {
                if ( this.$.dropdownItems.items.length === 1 && !this._selectedItems.find(item => item[this.keyColumn] === this.$.dropdownItems.items[0][this.keyColumn])) {
                  this._selectedItems = [...this._selectedItems, this.$.dropdownItems.items[0]];
                  this.lastSelectedItems = [...this.lastSelectedItems, this.$.dropdownItems.items[0]];

                  this._clearValueInput();
                  this.filterItems();
                }
              }
            }
            break;
          case 27: // escape
            this._closingKey = 'esc';
            if ( !this.multiSelection ) {
              this._selectedItems = this.lastSelectedItems;
              this.ironListSelectedItems = [];
              this.ironListSelectedItems = this._selectedItems;
              if ( this._selectedItems === undefined ) {
                this._clearValueInput();
              } else {
                this._setValueInInput();
              }
            }
            if ( this.opened ) {
              this.closeDropdown();
            } else {
              if ( this.searchInput ) {
                this.searchInput.blur();
              }
            }
            break;
          case 37: // left
            if ( this._doesntExistYet ) {
              this._moveSelection('up');
            }
            break;
          case 38: // up
            this._moveSelection('up');
            event.stopPropagation();
            break;
          case 39: // right
            if ( this._doesntExistYet ) {
              this._moveSelection('down');
            }
            break;
          case 40: // down
            this._moveSelection('down');
            event.stopPropagation();
            break;
          default:
            event.stopPropagation();
            return;
        }

        // The value-changed event is not fired for iron-input elements.
        if (this.multiSelection) this._boundDebounceFilterItems(event);
      }

      _moveSelection (direction) {
        if ( !this.multiSelection ) {
          let _selectedIndex = typeof this._selectedIndex === "undefined" || isNaN(this._selectedIndex) ? -1 : this._selectedIndex;
          let indexScroll = _selectedIndex;
          if ( direction === 'up' && _selectedIndex > 0 ) {
            _selectedIndex -= 1;
            indexScroll = _selectedIndex - 1;
          } else if ( direction === 'down' && _selectedIndex < this.filteredItems.length - 1 ) {
            _selectedIndex += 1;
            indexScroll = _selectedIndex - 1;
          }

          this.$.dropdownItems.selectItem( this.$.dropdownItems.items[_selectedIndex] );
          this._selectedIndex = _selectedIndex;
          this._selectedItems = this.$.dropdownItems.items[_selectedIndex];
          this.$.dropdownItems.scrollToIndex( indexScroll );

          if ( !this.opened ) {
            this._setValueInInput();
          }

        }
      }

      _targetElementChanged ( newTargetElement ) {
        if ( typeof newTargetElement === "object" && this.searchInline === true ) {
          this._unbindSearchInputListeners();
          this.searchInput = this.targetElement;
          this._bindSearchInputListeners();
        }
      }

      _bindSearchInputListeners () {
        if ( this.searchInput ) {
          if ( this.disabled ) {
            this.searchInput.setAttribute('disabled', '');
          }
          this._unbindSearchInputListeners();

          this.searchInput.addEventListener('blur', this._boundSearchInputBlurred);
          this.searchInput.addEventListener('focus', this._boundSearchInputFocused);
          this.searchInput.addEventListener('value-changed', this._boundDebounceFilterItems);
          this.searchInput.addEventListener('keydown', this._boundSearchInputKeyDownHandler);
          this.searchInput.addEventListener('keypress', this._boundSearchInputKeyPressHandler);

        }
      }

      _unbindSearchInputListeners () {
        if ( this.searchInput ) {
          this.searchInput.removeEventListener('blur', this._boundSearchInputBlurred);
          this.searchInput.removeEventListener('focus', this._boundSearchInputFocused);
          this.searchInput.removeEventListener('value-changed', this._boundDebounceFilterItems);
          this.searchInput.removeEventListener('keydown', this._boundSearchInputKeyDownHandler);
          this.searchInput.removeEventListener('keypress', this._boundSearchInputKeyPressHandler);
        }
      }

      _searchComboChanged ( newSearchComboValue, oldSearchComboValue ) {
        if ( newSearchComboValue && !oldSearchComboValue ) {
          this.searchInline = false;
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector('#searchInput'), () => {
            this.searchInput = this.shadowRoot.querySelector('#searchInput');
            this._bindSearchInputListeners();
          });
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector("#suffixIcon"), () => {
            this.shadowRoot.querySelector("#suffixIcon").addEventListener('click', this._boundClearSearch);
          });
        } else if ( newSearchComboValue === false && oldSearchComboValue === true ) {
          this._unbindSearchInputListeners();
        }
      }

      _searchInlineChanged ( newSearchInlineValue, oldSearchInlineValue ) {
        if ( newSearchInlineValue && !oldSearchInlineValue ) {
          this.searchCombo = false;
          this.searchInput = this.targetElement;
          this._bindSearchInputListeners();
        } else if ( newSearchInlineValue === false && oldSearchInlineValue !== newSearchInlineValue ) {
          this._unbindSearchInputListeners();
        }
      }

      _templateStyleChanged ( newTemplateStyle ) {
        const shadowRoot = this.shadowRoot;
        if ( shadowRoot.querySelector('#templateStyle') ) {
          shadowRoot.querySelector('#templateStyle').remove();
        }
        if ( newTemplateStyle !== undefined ) {
          const templateStyle = document.createElement('style');
          templateStyle.setAttribute('id', 'templateStyle');
          templateStyle.textContent = newTemplateStyle;
          shadowRoot.appendChild(templateStyle);
        }
      }

      _destroy () {
        this.ironListSelectedItems = null;
        this.filteredItems = [];
        this.lastSelectedItems = [];
        this._selectedItems = [];
        this._clearSearch();
        this._alreadyInitialized = false;
        this.initialId = undefined;
        if (this.opened) {
          this.closeDropdown();
        }
      }

      _itemColumn(item) {
        let csHTML;
        if ( this.template && this._templateToReplace !== undefined ) {
          let mapping = {};
          this._templateToReplace.forEach(e => mapping[`{${e}}`] = item[e]);
          csHTML = this._listItemInnerHTML(this.template.replace(/\{\w+\}/ig, n => mapping[n]));
        } else {
          csHTML = this._listItemInnerHTML(item[this.itemColumn]);
        }
        return csHTML;
      }

      _itemsChanged ( newItems ) {

        if ( newItems == undefined || newItems == null || newItems && newItems.length == 0 ) {
          return this._destroy();
        }

        if ( newItems && newItems && newItems.length > 0 && newItems[0].constructor === String) {
          let itemsConvertedToObject = [];
          newItems.forEach( (element, index) => itemsConvertedToObject.push({id: index, name: element}));
          // The following object change will trigger the observer again, so we do an early return
          this.items = itemsConvertedToObject;
          return;
        }
        if ( this.template && this.items.length > 0 ) {
          let found = [], rxp = /\{([^}]+)\}/g, curMatch;
          while ( (curMatch = rxp.exec( this.template )) ) {
            found.push( curMatch[1] );
          }
          this._templateToReplace = found;
        }

        for ( let [key, item] of Object.entries(this.items) ) {
          item._csHTML = this._itemColumn(item);
          this.items[key] = item;
        }
        if ( !this.filtering ) {
          this.filteredItems = this.items;
        }

        if ( this.items.length > 0 ) {
          this.filterItems(undefined, true);
          Polymer.RenderStatus.afterNextRender(this.searchInput, () => {
            this._resizeItemListHeight();
            this._resizeItemListWidth();
          });
          if ( typeof this._ignoreDisabledItems === "undefined" || this._ignoreDisabledItems === false ) {
            const currentDisabledItemsKeys = this.disabledItemsKeys;
            this.disabledItems = this.disabledItemsKeys = [];
            this.disableItems( currentDisabledItemsKeys );
          }
        } else {
          if ( typeof this._ignoreDisabledItems === "undefined" || this._ignoreDisabledItems === false ) {
            Polymer.RenderStatus.afterNextRender(this.searchInput, () => {
              this._unsetValueInInput();
            });
          }
        }
      }

      enableItems ( enabledItemsKeys ) {
        this.disableItems( this.disabledItemsKeys.filter(key => !enabledItemsKeys.includes(key)), true );
      }

      disableAllItems () {
        this.disableItems( [], false, true );
      }

      disableItems ( disabledItemsKeys, cleanPrevious = false, disableAll = false ) {
        let disabledItemsLength = disabledItemsKeys.length;
        let disabledItemsFound = 0;
        if ( disabledItemsLength > 0 ) {
          disabledItemsKeys = disabledItemsKeys.filter(key => !this.disabledItemsKeys.includes(key));
          disabledItemsLength = disabledItemsKeys.length;
        }
        if ( disabledItemsLength > 0 || cleanPrevious || disableAll ) {
          this.disabledItemsKeys = disabledItemsKeys;
          let items = [], disabledItems = [];
          for ( let [key, item] of Object.entries(this.items) ) {
            let newItem = JSON.parse(JSON.stringify( item ));
            if ( cleanPrevious ) {
              newItem.csDisabled = false;
            } else if ( disableAll ) {
              newItem.csDisabled = true;
            }
            if ( disabledItemsLength > 0 && disabledItemsFound < disabledItemsLength ) {
              for ( let disabledItemKey of disabledItemsKeys ) {
                if ( item[this.keyColumn] == disabledItemKey ) {
                  newItem.csDisabled = true;
                  disabledItemsFound++;
                  break;
                }
              }
            }
            if ( newItem.csDisabled ) {
              disabledItems.push({ index: key, key: item[this.keyColumn] });
            }
            items.push(newItem);
          }
          this.disabledItems = disabledItems;
          this._ignoreDisabledItems = true;
          this.items = [];
          this.items = items;
          this._ignoreDisabledItems = false;
          this.filterItems();
        }
      }

      deselectAllItems () {
        this._clearValueInput();
        this._tempItems = this.items || [];
        this.items = [];

        this._selectedItems = [];
        this.lastSelectedItems = [];
        this.ironListSelectedItems = [];
        this.items = this._tempItems;
        this._tempItems = undefined;
      }

      _disabledItemsChanged ( newDisabledItems ) {
        if ( newDisabledItems && newDisabledItems.length > 0 ) {
          if ( this.multiSelection ) {
            if ( this._selectedItems !== undefined ) {
              let selectedItems = [];
              for ( let [key, item] of Object.entries(this._selectedItems) ) {
                if ( !this.disabledItemsKeys.includes(item[this.keyColumn]) ) {
                  selectedItems.push(item);
                }
              }
              this._selectedItems = selectedItems;
            }
            if ( this.lastSelectedItems !== undefined ) {
              let lastSelectedItems = [];
              for ( let [key, item] of Object.entries(this.lastSelectedItems) ) {
                if ( !this.disabledItemsKeys.includes(item[this.keyColumn]) ) {
                  lastSelectedItems.push(item);
                }
              }
              this.lastSelectedItems = lastSelectedItems;
            }
          } else {
            if ( this._selectedItems !== undefined ) {
              if ( this.disabledItemsKeys.includes(this._selectedItems[this.keyColumn]) ) {
                this._selectedItems = undefined;
                if ( !this.opened ) {
                  this._clearValueInput();
                }
              }
            }
            if ( this.lastSelectedItems !== undefined ) {
              if ( this.disabledItemsKeys.includes(this.lastSelectedItems[this.keyColumn]) ) {
                this.lastSelectedItems = undefined;
              }
            }
          }
        }
      }

      _computedItemHtml (html) {
        this._debounceRender();
        return html;
      }

      _selectDisabled ( isSelectDisabled ) {
        if ( isSelectDisabled === true) {
          if ( this.searchInput ) {
            this.searchInput.setAttribute('disabled', '');
          }
          if ( this.opened ) {
            this.closeDropdown();
          }
        } else {
          if ( this.searchInput ) {
            this.searchInput.removeAttribute('disabled');
          }
        }

        this._setValue();
      }

      _multiSelectionChanged ( newMultiSelectionValue, oldMultiSelectionValue ) {
        if ( newMultiSelectionValue ) {
          this.$.dropdownItems.setAttribute('multi-selection', '');
          this._setMultiSelectionTarget();
        } else {
          this.$.dropdownItems.removeAttribute('multi-selection');
          this.multiSelectionTags = false;
        }
        this._selectedItems = [];
        this.lastSelectedItems = [];
      }

      _setMultiSelectionTarget () {
        if ( this.multiSelection ) {
          if ( !this.multiSelectionTagsElementParent ) {
            this.multiSelectionTags = true;
          }
          if ( this.multiSelectionTags ) {
            this._setPositionTarget(this.shadowRoot.querySelector('#dynamicListWithInput'));
          } else {
            this._setPositionTarget(this.shadowRoot.querySelector('#searchSelf'));
          }
        } else {
          this._setPositionTarget(this.shadowRoot.querySelector('#searchSelf'));
        }
      }

      _selectionEnabledChanged ( newSelectionEnabledValue ) {
        if ( newSelectionEnabledValue )  {
          this.$.dropdownItems.setAttribute('selection-enabled', '');
        } else {
          this.$.dropdownItems.removeAttribute('selection-enabled');
          this.ironListSelectedItems = null;
        }
      }

      _multiSelectionTagsDefined ( multiSelectionTags ) {
        this.noLabelFloat = multiSelectionTags;
        return multiSelectionTags ? 'multiSelectionWithTags' : '';
      }

      _computedDisabledSelect ( disabled ) {
        return disabled ? 'listDisabled' : '';
      }

      _computedItemDisabledClass ( disabled ) {
        return disabled ? 'dropdown-item-disabled' : '';
      }

      _computedItemSelectedClass ( selected ) {
        if ( this.opened ) {
          this._debounceFocus();
        }

        return selected ? 'dropdown-item-selected' : '';
      }

      _debounceRender (defaultTimeout = 15) {
        if ( typeof this._debounceRenderTimeout !== "undefined" ) {
          clearTimeout(this._debounceRenderTimeout);
        }
        this._debounceRenderTimeout = setTimeout(() => {
          this._selectItems();
        }, defaultTimeout);
      }

      _debounceFocus (defaultTimeout = 15) {
        if ( !this.searchInput ) {
          return;
        }
        if ( typeof this._debounceFocusTimeout !== "undefined" ) {
          clearTimeout(this._debounceFocusTimeout);
        }
        this._debounceFocusTimeout = setTimeout(() => {
          this.searchInput.blur();
          this.searchInput.focus();
        }, defaultTimeout);
      }

      openDropdown () {
        this.$.dropdown.positionTarget = this.targetElement;
        this.$.dropdown.open();
      }

      closeDropdown () {
        this.$.dropdown.close();
      }

      attachTo (element, options) {

        if ( this.resetOnOpen ) {
          this._clearSearch();
          this.ironListSelectedItems = null;
          this.filteredItems = this.items;
          this._selectedItems = [];
        }

        if ( options !== undefined ) {
          for ( let [key, value] of Object.entries(options) ) {
            this.key = value;
          }
        }

        this._setPositionTarget(element);
        this._resizeItemListHeight();
        this.openDropdown();

        Polymer.RenderStatus.afterNextRender(this.searchInput, () => {
          this._debounceFocus(0);
        });
      }

      _setPositionTarget (element) {
        this.$.dropdown.positionTarget = element;
        this.targetElement = element;
        this._resizeItemListWidth();
      }

      _debounceFilterItems (event) {
        event.stopImmediatePropagation();

        if ( typeof this._debounceFilterItemsTimeout === "undefined" ) {
          this.filterItems(event.detail.value);
          this._debounceFilterItemsTimeout = setTimeout(() => {}, 0);
          return;
        } else {
          clearTimeout(this._debounceFilterItemsTimeout);
        }

        this._debounceFilterItemsTimeout = setTimeout(() => this.filterItems(), 0);
      }

      filterItems (query, clearLast = false) {
        if ( typeof this.items === "undefined" || this.items.length === 0 || this.filtering === false ) {
          return;
        }

        if ( clearLast ) {
          this._lastQueryNormalized = this._lastQuery = undefined;
        }

        query = query || (this.searchInput ? this.searchInput.value : '');
        if ( query === this._lastQuery ) {
          return;
        }

        this._lastQuery = query;
        let filteredItems = [];

        let queryNormalized = (query.normalize('NFD').replace(/[\u0300-\u036f]/g, '')).toLowerCase().split(' ').filter((el) => el !== '');

        if ( typeof this._lastQueryNormalized !== "undefined" ) {
          if ( this._simpleArrayEqual(queryNormalized, this._lastQueryNormalized ? this._lastQueryNormalized : []) === true ) {
            return;
          }
        }

        if ( query !== '' ) {
          let highlightTemplate = this._highlightTemplate();

          this._lastQueryNormalized = queryNormalized;
          this.filteredItems = [];

          if ( this.template ) {
            this._filterTemplateHTML = this._filterTemplateHTML || document.createElement('div');
          }

          for ( let [key, item] of Object.entries(this.items) ) {

            let itemValue = this._itemColumn(item);

            if ( this.template ) {
              this._filterTemplateHTML.innerHTML = this._itemColumn(item);
              itemValue = this._filterTemplateHTML.textContent || this._filterTemplateHTML.innerText || itemValue;
            }

            let itemNormalized = itemValue.toString().normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();
            let modifications = [];

            for ( let term of queryNormalized ) {
              let indexOf = itemNormalized.indexOf(term);
              if ( indexOf !== -1 ) {
                modifications.push([indexOf, indexOf + term.length - 1]);
              }
            }

            if ( modifications.length > 0 && modifications.length == queryNormalized.length )  {
              let itemText;
              if ( this.template ) {
                itemText = this._itemColumn(item);
              } else {
                // Create highlight template tag around matches
                modifications = this._mergeOverlappedRanges(modifications);
                itemText = itemValue.substring(0, modifications[0][0]);
                for ( let m = 0; m < (modifications.length); m++ ) {
                  itemText += highlightTemplate.begin + itemValue.substring(modifications[m][0], modifications[m][1] + 1) + highlightTemplate.end;
                  if ( m === (modifications.length) - 1) {
                    itemText += itemValue.substring(modifications[m][1] + 1, itemValue.length);
                  } else {
                    itemText += itemValue.substring(modifications[m][1] + 1, modifications[m+1][0]);
                  }
                }
              }

              let newItem = JSON.parse(JSON.stringify( item ));
              newItem._csHTML = itemText;
              filteredItems.push(newItem);
            }
          }

          // @REVIEW:
          // This doesn't seem necessary nor important at this stage..
          // Dont remember why I added it, so I just commented it for now

          //if ( filteredItems.length === 0 ) {
            //this.searchInput.value = _lastQuery;
          //}
          this.filteredItems = [];
          this.filteredItems = filteredItems;
        } else {
          this._lastQueryNormalized = queryNormalized;
          this.filteredItems = [];
          this.filteredItems = this.items;
        }

        if ( this.resizeOnFilter ) {
          this._resizeItemListHeight();
        }

        try {
            this.shadowRoot.querySelector("#suffixIcon").style.opacity = this._lastQueryNormalized.length > 0 ? 1 : 0;
        } catch (e) {
          // Sometimes the #suffixIcon might not exist.
        }
      }

      _resizeItemListHeight (useFiltered = true) {
        let items = useFiltered ? this.filteredItems : this.items;
        if (this.listHeight) {
          this.$.dropdownItems.style.height = this.listHeight;
        }

        if (this.searchInput
            && !this._alreadyInitialized
            && this.initialId !== undefined
            && this.filteredItems
            && this.filteredItems.length > 0) {

          // Convert the initial id into an array to avoid code complexity on single selection.
          const initialIds = this.initialId.constructor === Array ? this.initialId : [this.initialId];
          let foundInitialIds = 0;

          for ( let [key, item] of Object.entries(this.items) ) {
            initialIds.forEach(initialId => {
              if (initialId.toString() === item[this.keyColumn].toString()) {
                this.$.dropdownItems.selectItem( this.$.dropdownItems.items[key] );
                foundInitialIds++;
              }
            });

            if (foundInitialIds >= initialIds.length) break;
          }

          // Mark this flag to not run this code section in the future
          this._alreadyInitialized = true;
          this._selectedItems = this.lastSelectedItems = JSON.parse(JSON.stringify(this.ironListSelectedItems));

          // Only set the value in the search input for single-selection.
          if (!this.multiSelection) this._setValueInInput();
        }
      }

      _resizeItemListWidth () {
        if (this.listWidth) {
          // This means the user specified a width via properties.
          this.$.dropdown.style.width = this.listWidth;
        } else if (this.targetElement && (this.fixedContainerWidth || !this.items || this.items.length === 0)) {
          // This means the dropdown will try to ajust to the container's width.
            this.$.dropdown.style.width = `${this.targetElement.offsetWidth}px`;
        } else if (this.targetElement && this.items && this.items.length > 0) {
          // The width will take into account the longest item.
          const longestItem = Math.max(...this.items.map(item => item[this.itemColumn].length));

          this.$.dropdown.style.width = `${Math.max(this.targetElement.offsetWidth, longestItem * this.listItemWidth)}px`;
        }

        this.$.dropdown.notifyResize();
      }

      _selectItems () {
        if ( this.filteredItems && this.filteredItems.length > 0 && this._selectedItems && ( !this.multiSelection || this._selectedItems.length > 0 )) {
          for ( let [key, item] of Object.entries(this.filteredItems) ) {
            if ( !this.multiSelection ) {
              if ( this._selectedItems[this.keyColumn] == item[this.keyColumn] ) {
                this.$.dropdownItems.selectItem( this.$.dropdownItems.items[key] );
              }
            } else {
              for ( let selItem of this._selectedItems ) {
                if ( selItem[this.keyColumn] == item[this.keyColumn] ) {
                  this.$.dropdownItems.selectItem( this.$.dropdownItems.items[key] );
                }
              }
            }
          }
        }
      }

      _setValue () {
        if ( this.disabled ) {
          this.value = '';
        } else {
          if ( this.multiSelection ) {
            this.value = this._selectedItems ? this._selectedItems.map(item => item[this.keyColumn]).join(this.multiSelectionValueSeperator) : '';
          } else {
            this.value = this._selectedItems ? this._selectedItems[this.keyColumn] : '';
          }
        }
      }

      get selectedItems () {
        return this.disabled ? null : this._selectedItems;
      }

      _highlightTemplate () {
        return { begin: `<${this.highlightTemplateTag} class="${this.highlightTtemplateClass}">`, end: `</${this.highlightTemplateTag}>` };
      }

      _simpleArrayEqual (arr1, arr2) {
        if ( arr1.length != arr2.length ) {
          return false;
        }
        for ( let i = 0, l=arr1.length; i < l; i++ ) {
          if ( arr1[i] != arr2[i] ) {
            return false;
          }
        }
        return true;
      }

      _mergeOverlappedRanges (ranges) {
        let result = [], last;
        ranges.sort((a, b) => a[0]-b[0] || a[1]-b[1]);
        ranges.forEach(r => {
          if ( !last || (r[0] - 1) > last[1] ) {
            result.push(last = r);
          } else if ( (r[1] - 1) > last[1] ) {
            last[1] = r[1];
          }
        });
        return result;
      }

      /**
       * Deselects all currently selected items when the user clicks the
       * clear icon.
       * @param {Object} event - The event that was triggered.
       */
      _clearSelectIconClicked (event) {
        event.stopImmediatePropagation();

        this.deselectAllItems();
        if (this.searchInput) this.searchInput.blur();
      }

      /**
       * Checks if there is at least one item selected to hide / display
       * the clear icon on the dropdown.
       * @param {Object|Array} selectedItems - The currently selected item(s).
       */
      _shouldDisplayClearIcon (selectedItems) {
        return !this.noClearIcon
          && selectedItems
          && Object.entries(selectedItems).length > 0;
      }

      _listItemInnerHTML (itemContents) {
        const iconElement = document.createElement('iron-icon');
        iconElement.setAttribute('icon', 'casper-icons:check');

        const textContainer = document.createElement('div');
        textContainer.classList.add('dropdown-item-text');
        textContainer.innerHTML = itemContents;

        const iconContainer = document.createElement('div');
        iconContainer.classList.add('dropdown-item-icon');
        iconContainer.appendChild(iconElement);

        return textContainer.outerHTML + iconContainer.outerHTML;
      }

      _inputHasValue () {
        return this._selectedItems &&
          ((this.multiSelection && this._selectedItems.length > 0) ||
          (!this.multiSelection && Object.entries(this._selectedItems).length > 0));
      }

      _searchInputBlurred () {
        this._shouldLabelFloat = this.searchInput.value || this._inputHasValue();
      }

      _searchInputFocused () {
        this._shouldLabelFloat = true;
      }
    }

  window.customElements.define(CasperSelect.is, CasperSelect);
  </script>
</dom-module>
