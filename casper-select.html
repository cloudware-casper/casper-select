<!--
  - Copyright (c) 2014-2016 Cloudware S.A. All rights reserved.
  -
  - This file is part of casper-select.
  -
  - casper-select is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-select  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-select.  If not, see <http://www.gnu.org/licenses/>.
  -
-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-fit-behavior/iron-fit-behavior.html">
<link rel="import" href="../iron-overlay-behavior/iron-overlay-behavior.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../casper-icons/casper-icons.html">
<link rel="import" href="casper-select-dropdown.html">

<dom-module id="casper-select">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      #dropdown {
        overflow: hidden;
        border: 1px solid black;
        background-color: white;
        display: flex;
        flex-direction: column;
        max-height: 99vh;
      }

       #listScroller {
        overflow: auto;
        -ms-overflow-style: -ms-autohiding-scrollbar;
        min-height: 70px;
        max-height: var(--casper-combo-box-overlay-max-height, 80vh);

        /* Fixes item background from getting on top of scrollbars on Safari */
        transform: translate3d(0,0,0);

        /* Enable momentum scrolling on iOS (iron-list v1.2+ no longer does it for us) */
        -webkit-overflow-scrolling: touch;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        flex-grow: 1;
      }

      #itemsList {
        @apply --casper-select-itemsList;
      }

      .listItem {
        padding: 0 3px;
        margin: 0;
        @apply --casper-select-listItem;
      }

      .listItem:hover {
        background-color: rgba(0, 0, 0, 0.1);
      }

      .listItem .highlight {
        border: 1px solid #ccc;
        font-weight: bold;
        border-radius: 4px;
        @apply --casper-select-listItem-highlight;
      }

      .listItem.itemSelected {
        background-color: #007e8e;
        color: white;
        @apply --casper-select-listItem-selected;
      }

      #noResults {
        text-align: center;
      }

      #searchSelf {
        width: 200px;
      }

      #suffixIcon {
        cursor: pointer;
      }

      #dynamicInputList {
        list-style-type: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
      }

      #dynamicInputList li {

      }

      :root {
        --paper-input-container-color: white;
        --paper-input-container-invalid-color: green;

        --paper-input-container: {
          padding: 0;
          background-color: var(--primary-color);
        };
        --paper-input-container-input: {
          color: white;
        };
        --paper-input-prefix: {
          color: white;
          height: 18px;
        };
        --paper-input-suffix: {
          color: white;
          height: 18px;
          opacity: 0;
        };
      }
    </style>

    <template is="dom-if" if="[[ searchDynamic ]]">
      <ul id="dynamicInputList">
        <li>A</li>
        <li>B</li>
        <li>C</li>
        <li class="input"><paper-input id="searchSelf" class="paper-input" no-label-float label="Escolha uma opção de exemplo" on-tap="selfInputClicked"></paper-input></li>
      </ul>
    </template>
    <casper-select-dropdown id="dropdown" no-overlap dynamic-align horizontal-align="auto" vertical-align="auto" no-cancel-on-esc-key>
      <slot name="search"></slot>
      <template is="dom-if" if="[[ searchCombo ]]">
        <paper-input tabindex="1" id="searchInput" class="paper-input" no-label-float label="pesquisar..">
          <iron-icon class="iron-icon" icon="casper-icons:search" slot="prefix"></iron-icon>
          <iron-icon id="suffixIcon" class="iron-icon" icon="casper-icons:clear" slot="suffix" alt="limpar" title="limpar"></iron-icon>
        </paper-input>
      </template>
      <div id="listScroller">
        <iron-list id="itemsList" scroll-target="listScroller" items="[[ filteredItems ]]" selected-items="{{ ironListSelectedItems }}">
          <template>
            <div on-tap="_itemClicked">
              <div class$="listItem [[ _computedItemSelectedClass(selected, index) ]]" style$="[[ listItemHeightStyle ]]" inner-h-t-m-l="[[ _computedItemHtml(item._csHTML) ]]"></div>
            </div>
          </template>
        </iron-list>
        <template is="dom-if" if="[[ noVisibleItems ]]">
          <div id="noResults">
            Lista vazia.
          </div>
        </template>
      </div>
      <slot name="status"></slot>
    </casper-select-dropdown>
  </template>
  <script>
    "use strict";

    function generateObjects(n) {
      let arr = [];
      while (arr.length < n) {
        let value = Math.round(Math.random() * n);
        let name = Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);
        arr.push({
          "id": value,
          "name": value + ": " + name
        });
      }
      return arr;
    }

    class CasperSelect extends Polymer.Element {

      static get is () {
        return 'casper-select';
      }

      static get properties () {
        return {
          /**
           * Items supplied
           * @type {Object}
           */
          items: {
            type: Object,
            value: () => generateObjects(100),
            observer: '_itemsChanged'
          },
          /**
           * Item Column -> default: "name"
           * @type {String}
           */
          itemColumn: {
            type: String,
            value: 'name'
          },
          /**
           * Key Column -> default: "id"
           * @type {String}
           */
          keyColumn: {
            type: String,
            value: 'id'
          },
          /**
           * Items actually present in the select
           * @type {Object}
           */
          filteredItems: {
            type: Object
          },
          /**
           * This option doesn't allow you to enter search terms that have no matches
           * Either shows matched or prevents your input
           * @type {Boolean}
           */
          smartFilter: {
            type: Boolean,
            value: true
          },
          /**
           * Activate or disable filtering
           * @type {Boolean}
           */
          filtering: {
            type: Boolean,
            value: true
          },
          /**
           * No visible items COMPUTED flag
           * smartFilter needs to be disabled for this value to become true
           * @type {Boolean}
           */
          noVisibleItems: {
            type: Boolean,
            value: false,
            computed: '_emptyList(filteredItems)'
          },
          /**
           * Iron List Internal Selected Items - DO NOT MANIPULATE
           * @type {Object}
           */
          ironListSelectedItems: {
            type: Object
          },
          /**
           * Casper-Select Internal Selected Items
           * DO NOT MANIPULATE
           * @type {Object}
           */
          selectedItems: {
            type: Object,
            observer: '_selectedItemsChanged'
          },
          /**
           * Casper-Select Internal Last Selected Items
           * DO NOT MANIPULATE
           * @type {Object}
           */
          lastSelectedItems: {
            type: Object,
          },
          /**
           * Template height per item in px
           * @type {Number}
           */
          listItemHeight: {
            type: Number,
            value: 20
          },
          /**
           * Template width per item in px
           * List Width = This value * Longest Item String
           * @type {Number}
           */
          listItemWidth: {
            type: Number,
            value: 20
          },
          /**
           * Template style override to enforce height - COMPUTED
           * @type {String}
           */
          listItemHeightStyle: {
            type: String,
            computed: '_listItemHeightDefined(listItemHeight)'
          },
          /**
           * If multi-selection should be enabled
           * @type {Boolean}
           */
          multiSelection: {
            type: Boolean,
            value: false,
            observer: '_multiSelectionChanged'
          },
          /**
           * Enable or disable selections
           * @type {Boolean}
           */
          selectionEnabled: {
            type: Boolean,
            value: false,
            observer: '_selectionEnabledChanged'
          },
          /**
           * When attached to an existing element, will use that same element for filtering
           * @type {Boolean}
           */
          searchInline: {
            type: Boolean,
            value: false,
            observer: '_searchInlineChanged'
          },
          /**
           * When attached to an existing element, will add an extra input to the "select dropdown" for filtering
           * @type {Object}
           */
          searchCombo: {
            type: Boolean,
            value: false,
            observer: '_searchComboChanged'
          },
          /**
           * Dynamically shows its own input, and uses it for filtering and for showing the selected option
           * Is also computed by the other two types of searches
           * @type {Object}
           */
          searchDynamic: {
            type: Boolean,
            value: false,
            computed: '_isDynamicSearch(searchInline, searchCombo)',
            observer: '_searchDynamicChanged'
          },
          /**
           * If we are not in "multiSelcetion" mode, will automatically close dropdown on select
           * @type {Boolean}
           */
          closeOnSelect: {
            type: Boolean,
            value: true
          },
          /**
           * HTML Tag that embodies the Highlighted text
           * Default: span
           * @type {String}
           */
          highlightTemplateTag: {
            type: String,
            value: 'span'
          },
          /**
           * CSS class applied to the Highlight Template Tag
           * @type {String}
           */
          highlightTtemplateClass: {
            type: String,
            value: 'highlight'
          },
          /**
           * Target element (if using exisitng input elements on the page) to attach the select dropdown to
           * @type {Object}
           */
          targetElement: {
            type: Object,
            observer: '_targetElementChanged'
          },
          /**
           * Fixed List Height
           * @type {Number}
           */
          listHeight: Number,
          /**
           * Fied List Width
           * @type {Number}
           */
          listWidth: Number,
          /**
           * Adjust list height when filtering results
           * @type {Boolean}
           */
          resizeOnFilter: {
            type: Boolean,
            value: true
          },
          /**
           * Current status of the dropdown
           * @type {Boolean}
           */
          opened: {
            type: Boolean,
            value: false
          },
          /**
           * Resets filtering and search term on a new attachment
           * @type {Boolean}
           */
          resetOnOpen: {
            type: Boolean,
            value: false
          }
        }
      }

      connectedCallback () {
        super.connectedCallback();

        this._boundDebounceFilterItems = this._debounceFilterItems.bind(this);
        this._boundSearchInputKeyDownHandler = this._searchInputKeyDownHandler.bind(this);
        this._boundSearchInputKeyPressHandler = this._searchInputKeyPressHandler.bind(this);
        this._boundClearSearch = this._clearSearch.bind(this);


        this.$.dropdown.addEventListener('opened-changed', e => this._onOpenedChanged(e));

        window.select = this;
      }

      _onOpenedChanged (e) {
        // Closing
        if ( e.detail.value === false ) {
          this.opened = false;
          if ( !this.multiSelection && ( this.searchDynamic || this.searchInline ) ) {
            // On close,
            this.lastSelectedItems = this.selectedItems;
            if ( this.selectedItems !== undefined ) {
              this._setValueInInput();
            } else {
              this._clearValueInput();
            }
          }
        // Opening
        } else {
          if ( typeof this._selectedIndex !== "undefined" ) {
            this.$.itemsList.scrollToIndex( this._selectedIndex );
          }
          this.opened = true;
          if ( !this.multiSelection && ( this.searchDynamic || this.searchInline ) ) {
            this._unsetValueInInput();
          }
        }
      }

      _clearValueInput () {
        this.searchInput.value = "";
      }

      _setValueInInput () {
        this._tempFiltering = this.filtering;
        this.filtering = false;
        this.searchInput.value = this.selectedItems[this.itemColumn];
        this.searchInput.setAttribute('readonly', '');
      }

      _unsetValueInInput() {
        this.searchInput.value = "";
        this.searchInput.removeAttribute('readonly');
        this._resizeItemListHeight();
        if ( typeof this._tempFiltering !== "undefined" ) {
          this.filtering = this._tempFiltering;
        }
      }

      _isDynamicSearch ( searchInline, searchCombo ) {
        return ( searchInline === false && searchCombo === false );
      }

      _searchDynamicChanged ( newValue, oldValue ) {
        if ( newValue && !oldValue ) {
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector('#searchSelf'), () => {
            this._resizeItemListHeight();
            this._setPositionTarget(this.shadowRoot.querySelector('#searchSelf'));
            this._unbindSearchInputListeners();
            this.searchInput = this.targetElement;
            this._bindSearchInputListeners();
          });
        }
      }

      _selectedItemsChanged ( newValue, oldValue ) {
        this.dispatchEvent(new CustomEvent('value-changed', {detail: {selectedItems: newValue}}));
      }

      selfInputClicked () {
        this.openDropdown();
      }

      _itemClicked (e) {

        if ( !this.selectionEnabled ) {
          return;
        }

        if ( !this.selectedItems || this.selectedItems.length === 0 ) {
          this.selectedItems = [];
        }

        let classList = e.target.classList.toString();

        if ( this.multiSelection ) {
          if ( classList.indexOf("itemSelected") !== -1 ) {
            for ( let [key, item] of Object.entries(this.selectedItems) ) {
              if ( item[this.keyColumn] == e.model.item[this.keyColumn] ) {
                this.selectedItems.splice(key, 1);
                return;
              }
            }
          } else {
            if ( typeof this.selectedItems === "undefined" ) {
              this.selectedItems = [];
            }
            this.selectedItems.push( e.model.item );
          }
        } else {
          if ( classList.indexOf("itemSelected") !== -1 ) {
            this.selectedItems = [];
            this._selectedIndex = -1;
          } else {
            this._selectedIndex = e.model.index;
            this.selectedItems = e.model.item;
            if ( this.closeOnSelect ) {
              this.closeDropdown();
            }
          }
        }
      }

      _emptyList (items) {
        return !items || items.length === 0 ? true : false;
      }

      _clearSearch () {
        this.searchInput.value = "";
        this.shadowRoot.querySelector("#suffixIcon").style.opacity = 0;
        this.shadowRoot.querySelector("#suffixIcon").removeEventListener('click', this._boundClearSearch);
      }

      _searchInputKeyPressHandler (event) {

        if ( !this.smartFilter || !this.filtering || !this.searchInput ) {
          return;
        }

        let key = event.keyCode || event.which;
        let nextLetter = String.fromCharCode(key);
        if (nextLetter.length > 0) {
          let searchTerm = this.searchInput.value + nextLetter;
          if (searchTerm.length > 0) {
            let _lastQuery = this.searchInput.value;
            this.filterItems(searchTerm);
            if (this.filteredItems.length === 0) {
              event.preventDefault();
              this.filterItems(_lastQuery);
            }
          }
        }
      }

      _searchInputKeyDownHandler (event) {
        let key = event.keyCode || event.which;
        switch (key) {
          case  9: // tab
          case 13: // enter
            this._closingKey = key == 13 ? 'enter' : (event.shiftKey === true ? 'shift+tab' : 'tab');
            if ( !this.multiSelection ) {
              this.lastSelectedItems = this.selectedItems;
              if ( this.opened ) {
                if ( this.closeOnSelect ) {
                  this.closeDropdown();
                }
              } else {
                if ( this.searchInput ) {
                  this.searchInput.blur();
                }
              }
            }
            break;
          case 27: // escape
            this._closingKey = 'esc';
            this.selectedItems = this.lastSelectedItems;
            this.ironListSelectedItems = this.selectedItems;
            if ( !this.multiSelection ) {
              if ( this.selectedItems === undefined ) {
                this._clearValueInput();
              } else {
                this._setValueInInput();
              }
            }
            if ( this.opened ) {
              this.closeDropdown();
            } else {
              if ( this.searchInput ) {
                this.searchInput.blur();
              }
            }
            break;
          case 38: // up
            this._moveSelection('up');
            event.stopPropagation();
            break;
          case 40: // down
            this._moveSelection('down');
            event.stopPropagation();
            break;
          default:
            event.stopPropagation();
            return;
        }
      }

      _moveSelection (direction) {
        if ( !this.multiSelection ) {
          let _selectedIndex = typeof this._selectedIndex === "undefined" || isNaN(this._selectedIndex) ? -1 : this._selectedIndex;
          let indexScroll = _selectedIndex;
          if ( direction === 'up' && _selectedIndex > 0 ) {
            _selectedIndex -= 1;
            indexScroll = _selectedIndex - 1;
          } else if ( direction === 'down' && _selectedIndex < this.filteredItems.length - 1 ) {
            _selectedIndex += 1;
            indexScroll = _selectedIndex - 1;
          }

          this.$.itemsList.selectItem( this.$.itemsList.items[_selectedIndex] );
          this._selectedIndex = _selectedIndex;
          this.selectedItems = this.$.itemsList.items[_selectedIndex];
          this.$.itemsList.scrollToIndex( indexScroll );

          if ( !this.opened ) {
            this._setValueInInput();
          }

        }
      }

      _targetElementChanged ( newValue, oldValue ) {
        if ( typeof newValue === "object" && this.searchInline === true ) {
          this._unbindSearchInputListeners();
          this.searchInput = this.targetElement;
          this._bindSearchInputListeners();
        }
      }

      _bindSearchInputListeners () {
        if ( this.searchInput ) {
          this._unbindSearchInputListeners();
          this.searchInput.addEventListener('value-changed', this._boundDebounceFilterItems);
          this.searchInput.addEventListener('keydown', this._boundSearchInputKeyDownHandler);
          this.searchInput.addEventListener('keypress', this._boundSearchInputKeyPressHandler);
        }
      }

      _unbindSearchInputListeners () {
        if ( this.searchInput ) {
          this.searchInput.removeEventListener('value-changed', this._boundDebounceFilterItems);
          this.searchInput.removeEventListener('keydown', this._boundSearchInputKeyDownHandler);
          this.searchInput.removeEventListener('keypress', this._boundSearchInputKeyPressHandler);
        }
      }

      _searchComboChanged ( newValue, oldValue ) {
        if ( newValue && !oldValue ) {
          this.searchInline = false;
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector('#searchInput'), () => {
            this.searchInput = this.shadowRoot.querySelector('#searchInput');
            this._bindSearchInputListeners();
          });
          Polymer.RenderStatus.afterNextRender(this.shadowRoot.querySelector("#suffixIcon"), () => {
            this.shadowRoot.querySelector("#suffixIcon").addEventListener('click', this._boundClearSearch);
          });
        } else if ( newValue === false && oldValue === true ) {
          this._unbindSearchInputListeners();
        }
      }

      _searchInlineChanged ( newValue, oldValue ) {
        if ( newValue && !oldValue ) {
          this.searchCombo = false;
          this.searchInput = this.targetElement;
          this._bindSearchInputListeners();
        } else if ( newValue === false && oldValue !== newValue ) {
          this._unbindSearchInputListeners();
        }
      }

      _itemsChanged ( newValue, oldValue ) {
        for ( let [key, item] of Object.entries(this.items) ) {
          item._csHTML = item[this.itemColumn];
          this.items[key] = item;
        }
        if ( !this.filtering ) {
          this.filteredItems = this.items;
        }
        this.filterItems();
      }

      _computedItemHtml(html) {
        this._debounceRender();
        return html;
      }

      _multiSelectionChanged ( newValue, oldValue ) {
        if ( newValue ) {
          this.$.itemsList.setAttribute('multi-selection', '');
        } else {
          this.$.itemsList.removeAttribute('multi-selection');
        }
        this.selectedItems = [];
      }

      _selectionEnabledChanged ( newValue, oldValue ) {
        if ( newValue )  {
          this.$.itemsList.setAttribute('selection-enabled', '')
        } else {
          this.$.itemsList.removeAttribute('selection-enabled');
          this.ironListSelectedItems = null;
        }
      }

      _listItemHeightDefined ( listItemHeight ) {
        return "height:" + listItemHeight + "px;";
      }

      _computedItemSelectedClass ( selected, index ) {
        if ( this.opened ) {
          this._debounceFocus();
        }
        return selected ? 'itemSelected' : '';
      }

      _debounceRender(defaultTimeout = 15) {
        if ( typeof this._debounceRenderTimeout !== "undefined" ) {
          clearTimeout(this._debounceRenderTimeout);
        }
        this._debounceRenderTimeout = setTimeout(() => {
          this._selectItems();
        }, defaultTimeout);
      }

      _debounceFocus (defaultTimeout = 15) {
        if ( !this.searchInput ) {
          return;
        }
        if ( typeof this._debounceFocusTimeout !== "undefined" ) {
          clearTimeout(this._debounceFocusTimeout);
        }
        this._debounceFocusTimeout = setTimeout(() => {
          this.searchInput.blur();
          this.searchInput.focus()
        }, defaultTimeout);
      }

      openDropdown () {
        this.$.dropdown.positionTarget = this.targetElement;
        this.$.dropdown.open();
      }

      closeDropdown () {
        this.$.dropdown.close();
      }

      attachTo (element, options) {

        if ( this.resetOnOpen ) {
          this._clearSearch();
          this.ironListSelectedItems = null;
          this.filteredItems = this.items;
          this.selectedItems = [];
        }

        if ( options !== undefined ) {
          for ( let [key, value] of Object.entries(options) ) {
            this.key = value;
          }
        }

        this._setPositionTarget(element);
        this._resizeItemListHeight();

        this.openDropdown();

        Polymer.RenderStatus.afterNextRender(this.searchInput, () => {
          this._debounceFocus(0);
        });
      }

      _setPositionTarget (element) {
        this.$.dropdown.positionTarget = element;
        this.targetElement = element;

        if ( typeof this.listWidth != "undefined" && this.listWidth > 0 ) {
          this.$.dropdown.style.width = this.listWidth + 'px';
        } else {
          let longestItem = this.items.reduce( (a, b) => a[this.itemColumn].length > b[this.itemColumn].length ? a : b );
          this.$.dropdown.style.width = Math.max(this.targetElement.offsetWidth, longestItem[this.itemColumn].length * this.listItemWidth) + 'px';
        }
      }

      _debounceFilterItems (event) {
        if ( typeof this._debounceFilterItemsTimeout === "undefined" ) {
          this.filterItems(event.detail.value);
          this._debounceFilterItemsTimeout = setTimeout(() => {}, 0);
          return;
        } else {
          clearTimeout(this._debounceFilterItemsTimeout);
        }
        this._debounceFilterItemsTimeout = setTimeout((e) => this.filterItems(), 0);
      }

      filterItems (query) {
        if ( typeof this.items === "undefined" || this.items.length === 0 || this.filtering === false ) {
          return;
        }

        query = query || (this.searchInput ? this.searchInput.value : '');
        if ( query === this._lastQuery ) {
            return;
        }
        let _lastQuery = this._lastQuery;
        this._lastQuery = query;
        let filteredItems = [];

        if ( query !== '' ) {
          let highlightTemplate = this._highlightTemplate();
          let queryNormalized = (query.normalize('NFD').replace(/[\u0300-\u036f]/g, '')).toLowerCase().split(' ').filter(function(el) { return el !== '' });

          if ( this._simpleArrayEqual(queryNormalized, this._lastQueryNormalized ? this._lastQueryNormalized : []) === true ) {
            return;
          }

          this._lastQueryNormalized = queryNormalized;
          this.filteredItems = [];

          for ( let [key, item] of Object.entries(this.items) ) {
            let itemValue = item[this.itemColumn];
            let itemNormalized = itemValue.toString().normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();
            let modifications = [];

            for ( let term of queryNormalized ) {
              let indexOf = itemNormalized.indexOf(term);
              if ( indexOf !== -1 ) {
                modifications.push([indexOf, indexOf + term.length - 1]);
              }
            }

            if ( modifications.length > 0 && modifications.length == queryNormalized.length )  {
              modifications = this._mergeOverlappedRanges(modifications);
              let itemText = itemValue.substring(0, modifications[0][0]);
              for ( let m = 0; m < (modifications.length); m++ ) {
                itemText += highlightTemplate.begin + itemValue.substring(modifications[m][0], modifications[m][1] + 1) + highlightTemplate.end;
                if ( m === (modifications.length) - 1) {
                  itemText += itemValue.substring(modifications[m][1] + 1, itemValue.length);
                } else {
                  itemText += itemValue.substring(modifications[m][1] + 1, modifications[m+1][0]);
                }
              }
              let newItem = this._copyObject(item);
              newItem["_csHTML"] = itemText;
              filteredItems.push(newItem);
            }
          }

          // @REVIEW:
          // This doesn't seem necessary nor important at this stage..
          // Dont remember why I added it, so I just commented it for now

          //if ( filteredItems.length === 0 ) {
            //this.searchInput.value = _lastQuery;
          //}

          this.filteredItems = filteredItems;
        } else {
          this._lastQueryNormalized = [];
          this.filteredItems = this.items;
        }

        if ( this.resizeOnFilter ) {
          this._resizeItemListHeight(true);
        }

        try {
            this.shadowRoot.querySelector("#suffixIcon").style.opacity = this._lastQueryNormalized.length > 0 ? 1 : 0;
        } catch (e) {}

      }

      _resizeItemListHeight (useFiltered = false) {
        let items = useFiltered ? this.filteredItems : this.items;
        if ( typeof this.listHeight != "undefined" && this.listHeight > 0 ) {
          this.$.itemsList.style.height = (this.listHeight) + 'px';
        } else {
          this.$.itemsList.style.height = (Object.keys(items).length * this.listItemHeight) + 'px';
        }
      }

      _selectItems () {
        if ( this.filteredItems && this.filteredItems.length > 0 && this.selectedItems && ( !this.multiSelection || this.selectedItems.length > 0 )) {
          for ( let [key, item] of Object.entries(this.filteredItems) ) {
            if ( !this.multiSelection ) {
              if ( this.selectedItems[this.keyColumn] == item[this.keyColumn] ) {
                this.$.itemsList.selectItem( this.$.itemsList.items[key] );
              }
            } else {
              for ( let selItem of this.selectedItems ) {
                if ( selItem[this.keyColumn] == item[this.keyColumn] ) {
                  this.$.itemsList.selectItem( this.$.itemsList.items[key] );
                }
              }
            }
          }
        }
      }

      _highlightTemplate () {
        return { begin: '<' + this.highlightTemplateTag + ' class="' + this.highlightTtemplateClass + '">', end: '</' + this.highlightTemplateTag + '>' };
      }

      _simpleArrayEqual (arr1, arr2) {
        if ( arr1.length != arr2.length ) {
          return false;
        }
        for ( let i = 0, l=arr1.length; i < l; i++ ) {
          if ( arr1[i] != arr2[i] ) {
            return false;
          }
        }
        return true;
      }

      _copyObject (src) {
        let copy = {};
        for ( let prop in src ) {
          if ( src.hasOwnProperty(prop) ) {
            copy[prop] = src[prop];
          }
        }
        return copy;
      }

      _mergeOverlappedRanges (ranges) {
        let result = [], last;

        ranges.sort(function(a, b) { return a[0]-b[0] || a[1]-b[1] })
        ranges.forEach(function (r) {
          if ( !last || (r[0] - 1) > last[1] ) {
            result.push(last = r);
          } else if ( (r[1] - 1) > last[1] ) {
            last[1] = r[1];
          }
        });

        return result;
      }

    }

  window.customElements.define(CasperSelect.is, CasperSelect);
  </script>
</dom-module>